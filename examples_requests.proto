/////////////////
// Keynet Identity Map (default)
/////////////////

// Create the mapping
message CreateMappingRequest {
    mapping = Mapping {
        id = "keynet_v1.1",
        create_validator = [ Validator {
            operation = [
                // bootstrap with CAs
                OpCASignature {},
                // bootstrap with previous version
                OpPreviousVersion {
                    allowed_version_ids = ["keynet_v1.0"] 
                },
            ]
        }],
        update_validator = [ Validator {
            operation = [
                // require keynet signature for updates
                OpOwnerSignature {}
            ]
        }]
        key_type = ALIAS
        value_type = PUBLIC_KEY
    }
}

// Create an entry
message UpdateRequest {
    update = EntryUpdate {
        mapping_id = "keynet_v1.0",       
        key = Alias {
            Email {
                address = "colinman@stanford.edu"
                domain = "stanford.edu"
            }
        }
        value = "{public key here}"
    },
    signature = ["{stanford.edu CA PKI-based signature to prove ownership}"]
}

// Create an entry from an existing entry in a previous mapping
// version (1.0 -> 1.1)
message UpdateRequest {
    update = EntryUpdate {
        mapping_id = "keynet_v1.1",       
        key = Alias {
            Email {
                address = "colinman@stanford.edu"
                domain = "stanford.edu"
            }
        }
        value = "{public key here}"
    },
    signature = [] // nothing, the entry is already signed and present in keynet_v1.0
} 

// Update entry to require n of m signatures 
// for future updates
message UpdateRequest {
    update = EntryUpdate {
        mapping_id = "keynet_v1.1",       
        key = Alias {
            Email {
                address = "colinman@stanford.edu"
                domain = "stanford.edu"
            }
        }
        value = "{new public key here}"
        update_validator = [ Validator {
            operation = [
                n_of_m_sig = OpNOfMSignatures {
                    alias = ["eff.org", "mozilla.org", "ietf.org"],
                    required_number = 2
                    
                }
            ]
        }]
    },
    signature = ["{sig1}", "sig2", "sig3"]
}

/////////////////
// Binary Hashes
/////////////////

// Create the mapping
message CreateMappingRequest {
    mapping = Mapping {
        id = "binary",
        create_validator = [ Validator {
            operation = [
                // require signature by owner to update
                OpOwnerSignature {}
            ]
        }],
        update_validator = [ Validator {
            operation = [
                // require keynet signature for updates
                OpOwnerSignature {}
            ]
        }]
        key_type = URL
        value_type = SHA256HASH
    }
}

// Create an entry
message UpdateRequest {
    update = EntryUpdate {
        mapping_id = "binary",       
        key = Url {
            path = "/download/file.zip"
            domain = "stanford.edu"
        }
        value = "{hash value here}"
    },
    signature = ["{signature of EntryUpdate}"]
}

// Update entry to require n of m signatures 
// for future updates
message UpdateRequest {
    update = EntryUpdate {
        mapping_id = "binary",       
        key = Url {
            path = "/download/file.zip"
            domain = "stanford.edu"
        }
        value = "{hash value here}"
        update_validator = [ Validator {
            operation = [
                n_of_m_sig = OpNOfMSignatures {
                    alias = ["eff.org", "mozilla.org", "ietf.org"],
                    required_number = 2
                    
                }
            ]
        }]
    },
    signature = ["{sig1}", "sig2", "sig3"]
}
